#region COPYRIGHT
// (c)2012 MuchDifferent. All Rights Reserved.
#endregion
using System.Globalization;

// WARNING: The following code is auto generated by a text template and may be overwritten at any time.

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#

var types = new[,]
{
	{ "Int", ", NumberStyles.Integer, NumberFormatInfo.InvariantInfo" },
	{ "UInt", ", NumberStyles.Integer, NumberFormatInfo.InvariantInfo" },
	{ "Long", ", NumberStyles.Integer, NumberFormatInfo.InvariantInfo" },
	{ "ULong", ", NumberStyles.Integer, NumberFormatInfo.InvariantInfo" },
	{ "Bool", "" },
	{ "Float", ", NumberStyles.Float | NumberStyles.AllowThousands, NumberFormatInfo.InvariantInfo" },
	{ "Double", ", NumberStyles.Float | NumberStyles.AllowThousands, NumberFormatInfo.InvariantInfo" },
};

#>
namespace uLink
{
	public static partial class NetworkPrefs
	{
<#
for (int i = 0; i < types.GetLength(0); i++) {
	var name = types[i, 0];
	var type = name.ToLower();
	var format = types[i, 1];
#>
		public static <#= type #> Get<#= name #>(string key, <#= type #> defaultValue)
		{
			<#= type #> value;
			return _TryParse(GetString(key), out value) ? value : defaultValue;
		}

		public static bool TryGet<#= name #>(string key, ref <#= type #> value)
		{
			<#= type #> keyValue;
			if (_TryParse(GetString(key), out keyValue))
			{
				value = keyValue;
				return true;
			}
			
			return false;
		}

		public static void Set<#= name #>(string key, <#= type #> value)
		{
			SetString(key, value.ToString());
		}

		public static <#= type #> Get(string key, <#= type #> defaultValue) { return Get<#= name #>(key, defaultValue); }

		public static bool TryGet(string key, ref <#= type #> value) { return TryGet<#= name #>(key, ref value); }

		public static void Set(string key, <#= type #> value) { Set<#= name #>(key, value); }

		private static bool _TryParse(string s, out <#= type #> result)
		{
			return <#= type #>.TryParse(s<#= format #>, out result);
		}

<#
}
#>
	}
}
